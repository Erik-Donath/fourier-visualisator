<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fourier Playground</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Unbounded:wght@300;700;900&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --card: #1a1a28;
    --accent1: #00ffcc;
    --accent2: #ff3aff;
    --accent3: #ffcc00;
    --accent4: #3a9fff;
    --text: #e8e8f0;
    --muted: #6060a0;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    overflow-x: hidden;
  }

  /* GRID BACKGROUND */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: 
      linear-gradient(rgba(0,255,204,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,255,204,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 24px;
    position: relative;
    z-index: 1;
  }

  /* HEADER */
  header {
    padding: 60px 0 40px;
    text-align: center;
  }

  .header-tag {
    font-size: 11px;
    letter-spacing: 4px;
    color: var(--accent1);
    text-transform: uppercase;
    margin-bottom: 16px;
  }

  h1 {
    font-family: 'Unbounded', sans-serif;
    font-size: clamp(40px, 8vw, 80px);
    font-weight: 900;
    line-height: 1;
    background: linear-gradient(135deg, var(--accent1) 0%, var(--accent2) 50%, var(--accent3) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 16px;
  }

  .subtitle {
    color: var(--muted);
    font-size: 13px;
    letter-spacing: 1px;
  }

  /* NAV TABS */
  .tabs {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
    margin: 40px 0;
  }

  .tab-btn {
    padding: 10px 20px;
    background: var(--card);
    border: 1px solid var(--muted);
    color: var(--muted);
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    letter-spacing: 1px;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
  }

  .tab-btn:hover, .tab-btn.active {
    border-color: var(--accent1);
    color: var(--accent1);
    background: rgba(0,255,204,0.05);
    box-shadow: 0 0 20px rgba(0,255,204,0.15);
  }

  /* SECTIONS */
  .section {
    display: none;
    animation: fadeIn 0.4s ease;
  }
  .section.active { display: block; }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .section-header {
    margin-bottom: 32px;
  }

  .section-title {
    font-family: 'Unbounded', sans-serif;
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 8px;
  }

  .section-desc {
    color: var(--muted);
    font-size: 13px;
    line-height: 1.8;
    max-width: 700px;
  }

  /* CARDS */
  .card {
    background: var(--card);
    border: 1px solid rgba(255,255,255,0.06);
    padding: 28px;
    margin-bottom: 24px;
  }

  .card-title {
    font-family: 'Unbounded', sans-serif;
    font-size: 14px;
    color: var(--accent3);
    margin-bottom: 16px;
    letter-spacing: 1px;
  }

  /* CANVAS */
  canvas {
    display: block;
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.05);
  }

  /* CONTROLS */
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    margin-top: 20px;
    align-items: center;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 120px;
  }

  .control-group label {
    font-size: 11px;
    color: var(--muted);
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  input[type=range] {
    -webkit-appearance: none;
    width: 100%;
    height: 4px;
    background: var(--muted);
    outline: none;
    cursor: pointer;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    background: var(--accent1);
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 0 8px var(--accent1);
  }

  .val-display {
    font-size: 12px;
    color: var(--accent1);
    min-width: 40px;
  }

  /* BUTTONS */
  .btn {
    padding: 10px 20px;
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    letter-spacing: 1px;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
    border: none;
  }

  .btn-primary {
    background: var(--accent1);
    color: var(--bg);
  }
  .btn-primary:hover {
    box-shadow: 0 0 20px var(--accent1);
    transform: translateY(-1px);
  }

  .btn-secondary {
    background: transparent;
    color: var(--accent2);
    border: 1px solid var(--accent2);
  }
  .btn-secondary:hover {
    background: rgba(255,58,255,0.1);
    box-shadow: 0 0 16px rgba(255,58,255,0.3);
  }

  .btn-accent {
    background: transparent;
    color: var(--accent3);
    border: 1px solid var(--accent3);
  }
  .btn-accent:hover {
    background: rgba(255,204,0,0.1);
  }

  /* TWO COLUMN LAYOUT */
  .two-col {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
  }

  @media (max-width: 700px) {
    .two-col { grid-template-columns: 1fr; }
  }

  /* FREQ BARS */
  .freq-display {
    display: flex;
    align-items: flex-end;
    gap: 3px;
    height: 120px;
    padding: 8px;
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.05);
    overflow: hidden;
  }

  .freq-bar {
    flex: 1;
    background: linear-gradient(to top, var(--accent1), var(--accent2));
    transition: height 0.05s ease;
    min-height: 2px;
    border-radius: 2px 2px 0 0;
  }

  /* INFO BOX */
  .info-box {
    background: rgba(0,255,204,0.04);
    border-left: 3px solid var(--accent1);
    padding: 16px 20px;
    margin-top: 20px;
    font-size: 13px;
    line-height: 1.8;
    color: #a0a0c0;
  }

  /* WAVEFORM BUILDER SPECIFIC */
  .harmonic-row {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 0;
    border-bottom: 1px solid rgba(255,255,255,0.04);
  }

  .harmonic-label {
    font-size: 12px;
    width: 80px;
    color: var(--muted);
  }

  /* SPECTRUM ANALYZER */
  #spectrumNote {
    font-family: 'Unbounded', sans-serif;
    font-size: 28px;
    font-weight: 700;
    color: var(--accent2);
    text-align: center;
    margin: 12px 0;
    min-height: 40px;
  }

  /* DRAWING CANVAS */
  #drawCanvas {
    cursor: crosshair;
    touch-action: none;
  }

  /* EPICYCLES */
  #epicycleCanvas {
    display: block;
    margin: 0 auto;
  }

  .two-row {
    display: grid;
    grid-template-rows: auto auto;
    gap: 16px;
  }

  .badge {
    display: inline-block;
    padding: 3px 10px;
    font-size: 10px;
    letter-spacing: 2px;
    border: 1px solid;
    text-transform: uppercase;
    margin-right: 8px;
  }
  .badge-green { border-color: var(--accent1); color: var(--accent1); }
  .badge-pink { border-color: var(--accent2); color: var(--accent2); }
  .badge-yellow { border-color: var(--accent3); color: var(--accent3); }

  footer {
    text-align: center;
    padding: 40px;
    color: var(--muted);
    font-size: 11px;
    letter-spacing: 2px;
    border-top: 1px solid rgba(255,255,255,0.05);
    margin-top: 60px;
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <p class="header-tag">Oberstufe ¬∑ Mathematik ¬∑ Signalverarbeitung</p>
    <h1>FOURIER<br>PLAYGROUND</h1>
    <p class="subtitle">FT ¬∑ DFT ¬∑ FFT ‚Äî spielerisch erkunden</p>
  </header>

  <nav class="tabs">
    <button class="tab-btn active" onclick="showTab('builder')">üéµ Wellenformbauer</button>
    <button class="tab-btn" onclick="showTab('epicycles')">üåÄ Epizykel</button>
    <button class="tab-btn" onclick="showTab('drawing')">‚úèÔ∏è Zeichnen ‚Üí FFT</button>
    <button class="tab-btn" onclick="showTab('analyzer')">üéôÔ∏è Mikrofon-Spektrum</button>
    <button class="tab-btn" onclick="showTab('image')">üñºÔ∏è Bild-FFT</button>
  </nav>

  <!-- === TAB 1: WELLENFORMBAUER === -->
  <div id="tab-builder" class="section active">
    <div class="section-header">
      <p class="section-title">üéµ Wellenformbauer</p>
      <p class="section-desc">
        Addiere verschiedene Sinuswellen und sieh, wie komplexe T√∂ne entstehen.
        <span class="badge badge-green">FT-Grundprinzip</span>
        Jede Welle = eine Frequenz im Spektrum.
      </p>
    </div>

    <div class="two-col">
      <div class="card">
        <p class="card-title">Zeitbereich (Wellenform)</p>
        <canvas id="waveCanvas" width="500" height="180" style="width:100%;"></canvas>
        <div id="harmonics"></div>
        <div class="controls" style="margin-top:16px;">
          <button class="btn btn-primary" onclick="addHarmonic()">+ Frequenz hinzuf√ºgen</button>
          <button class="btn btn-secondary" onclick="clearHarmonics()">Alles l√∂schen</button>
          <button class="btn btn-accent" onclick="presetSquare()">Rechteckwelle</button>
          <button class="btn btn-accent" onclick="presetSawtooth()">S√§gezahn</button>
        </div>
      </div>

      <div class="card">
        <p class="card-title">Frequenzbereich (Spektrum)</p>
        <canvas id="specCanvas" width="500" height="180" style="width:100%;"></canvas>
        <div class="info-box">
          üí° <b>Das ist die Fouriertransformation!</b><br>
          Links siehst du die Welle in der Zeit. Rechts siehst du, aus welchen Frequenzen sie besteht.
          Die FT "zerlegt" die Welle in ihre Bauteile.
        </div>
      </div>
    </div>
  </div>

  <!-- === TAB 2: EPIZYKEL === -->
  <div id="tab-epicycles" class="section">
    <div class="section-header">
      <p class="section-title">üåÄ Rotierende Kreise (Epizykel)</p>
      <p class="section-desc">
        Jede Sinuswelle ist ein rotierender Zeiger. Addiert man viele zusammen, kann man beliebige Formen zeichnen!
        <span class="badge badge-pink">Visuell</span> Das ist das geometrische Herz der Fouriertransformation.
      </p>
    </div>

    <div class="card">
      <p class="card-title">Epizykel-Visualisierung</p>
      <div style="display:flex; gap:24px; flex-wrap:wrap; align-items:flex-start;">
        <canvas id="epicycleCanvas" width="400" height="400" style="flex-shrink:0; max-width:100%;"></canvas>
        <div style="flex:1; min-width:200px;">
          <div id="epi-harmonics" style="margin-bottom:16px;"></div>
          <button class="btn btn-primary" onclick="addEpiCycle()" style="margin-bottom:8px; display:block; width:100%;">+ Kreis hinzuf√ºgen</button>
          <button class="btn btn-secondary" onclick="clearEpiCycles()" style="display:block; width:100%;">Reset</button>
          <div class="info-box" style="margin-top:20px;">
            üí° <b>Wie funktioniert das?</b><br>
            Jeder Kreis dreht sich mit einer bestimmten Frequenz. Der Stift am Ende zeichnet die Summe aller Bewegungen ‚Äî das ergibt die Wellenform!
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- === TAB 3: ZEICHNEN === -->
  <div id="tab-drawing" class="section">
    <div class="section-header">
      <p class="section-title">‚úèÔ∏è Zeichnen & Analysieren</p>
      <p class="section-desc">
        Zeichne eine beliebige Wellenform mit der Maus. Die DFT zerlegt sie sofort in ihre Frequenzanteile!
        <span class="badge badge-yellow">DFT</span>
      </p>
    </div>

    <div class="two-col">
      <div class="card">
        <p class="card-title">Zeichenfl√§che ‚Äî male deine Wellenform</p>
        <canvas id="drawCanvas" width="500" height="200" style="width:100%;"></canvas>
        <div class="controls">
          <button class="btn btn-primary" onclick="analyzeDrawing()">‚ñ∂ FFT analysieren</button>
          <button class="btn btn-secondary" onclick="clearDrawing()">L√∂schen</button>
        </div>
        <div class="info-box">
          üñäÔ∏è Zeichne eine Kurve von links nach rechts!<br>
          Tipp: Versuche eine Sinuswelle, eine Rechteckwelle, oder einfach etwas Wildes.
        </div>
      </div>
      <div class="card">
        <p class="card-title">FFT-Ergebnis (Frequenzspektrum)</p>
        <canvas id="drawSpecCanvas" width="500" height="200" style="width:100%;"></canvas>
        <div id="drawResult" class="info-box">
          üëÜ Zeichne erst eine Linie, dann klicke "FFT analysieren".
        </div>
      </div>
    </div>
  </div>

  <!-- === TAB 4: MIKROFON === -->
  <div id="tab-analyzer" class="section">
    <div class="section-header">
      <p class="section-title">üéôÔ∏è Live-Mikrofon-Spektrum</p>
      <p class="section-desc">
        Sieh in Echtzeit, welche Frequenzen in deiner Stimme oder Musik stecken. Die FFT berechnet das 60x pro Sekunde!
        <span class="badge badge-green">FFT ¬∑ Echtzeit</span>
      </p>
    </div>

    <div class="card">
      <p class="card-title">Frequenzspektrum ‚Äî Live</p>
      <p id="spectrumNote">‚Äî</p>
      <div class="freq-display" id="freqBars"></div>
      <canvas id="spectrogramCanvas" width="800" height="120" style="width:100%; margin-top:12px;"></canvas>
      <div class="controls" style="margin-top:16px;">
        <button class="btn btn-primary" id="micBtn" onclick="toggleMic()">üéôÔ∏è Mikrofon aktivieren</button>
        <div class="control-group" style="min-width:200px;">
          <label>Verst√§rkung</label>
          <input type="range" id="gainSlider" min="1" max="10" value="3" oninput="document.getElementById('gainVal').textContent=this.value">
          <span class="val-display" id="gainVal">3</span>
        </div>
      </div>
      <div class="info-box">
        üí° <b>Das macht dein Handy!</b><br>
        Jede Audio-App, Spracherkennung und Noisecancelling nutzt genau diese FFT-Analyse deiner Stimme in Echtzeit.
        Die FFT macht das tausende Male pro Sekunde schneller als die naive DFT.
      </div>
    </div>
  </div>

  <!-- === TAB 5: BILD === -->
  <div id="tab-image" class="section">
    <div class="section-header">
      <p class="section-title">üñºÔ∏è Bild-FFT</p>
      <p class="section-desc">
        Nicht nur T√∂ne ‚Äî auch Bilder lassen sich fouriertransformieren! Hohe Frequenzen = scharfe Kanten. Tiefe Frequenzen = sanfte Farbverl√§ufe.
        <span class="badge badge-pink">2D-FFT</span>
      </p>
    </div>

    <div class="card">
      <p class="card-title">W√§hle ein Testbild</p>
      <div style="display:flex; gap:12px; flex-wrap:wrap; margin-bottom:16px;">
        <button class="btn btn-primary" onclick="generatePattern('checker')">Schachbrett</button>
        <button class="btn btn-accent" onclick="generatePattern('stripes')">Streifen</button>
        <button class="btn btn-secondary" onclick="generatePattern('circle')">Kreis</button>
        <button class="btn btn-accent" onclick="generatePattern('noise')">Rauschen</button>
        <button class="btn btn-primary" onclick="generatePattern('gradient')">Verlauf</button>
      </div>
      <div class="two-col">
        <div>
          <p style="font-size:12px; color:var(--muted); margin-bottom:8px;">ORIGINALBILD</p>
          <canvas id="imgCanvas" width="256" height="256" style="width:100%; image-rendering:pixelated;"></canvas>
        </div>
        <div>
          <p style="font-size:12px; color:var(--muted); margin-bottom:8px;">FFT-SPEKTRUM (Magnitude)</p>
          <canvas id="fftCanvas" width="256" height="256" style="width:100%; image-rendering:pixelated;"></canvas>
        </div>
      </div>
      <div id="imgInfo" class="info-box" style="margin-top:16px;">
        üëÜ W√§hle ein Testbild aus, um die 2D-FFT zu sehen.
      </div>
      <div style="margin-top:16px;">
        <p style="font-size:12px; color:var(--muted); margin-bottom:8px;">TIEFPASS-FILTER (entfernt hohe Frequenzen = weichzeichnen)</p>
        <div class="controls">
          <div class="control-group" style="flex:1;">
            <label>Filterradius</label>
            <input type="range" id="filterRadius" min="5" max="120" value="60" oninput="applyFilter()">
          </div>
          <canvas id="filteredCanvas" width="256" height="256" style="height:80px; width:auto; image-rendering:pixelated;"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<footer>FOURIER PLAYGROUND ¬∑ F√úR DIE OBERSTUFE GEMACHT ¬∑ ALLE BERECHNUNGEN IM BROWSER</footer>

<script>
// =====================================================
// UTILITIES
// =====================================================
function showTab(id) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('tab-' + id).classList.add('active');
  event.target.classList.add('active');
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  return [r,g,b];
}

// =====================================================
// TAB 1: WELLENFORMBAUER
// =====================================================
let harmonics = [{freq:1, amp:1, color:'#00ffcc'}];

const waveCtx = document.getElementById('waveCanvas').getContext('2d');
const specCtx = document.getElementById('specCanvas').getContext('2d');

const COLORS = ['#00ffcc','#ff3aff','#ffcc00','#3a9fff','#ff6b3a','#a0ff3a'];

function drawWave() {
  const canvas = waveCtx.canvas;
  const W = canvas.width, H = canvas.height;
  waveCtx.fillStyle = '#12121a';
  waveCtx.fillRect(0,0,W,H);
  // Grid
  waveCtx.strokeStyle = 'rgba(255,255,255,0.05)';
  waveCtx.lineWidth = 1;
  for(let y=0; y<H; y+=H/4) { waveCtx.beginPath(); waveCtx.moveTo(0,y); waveCtx.lineTo(W,y); waveCtx.stroke(); }

  // Individual waves (faint)
  harmonics.forEach(h => {
    waveCtx.strokeStyle = h.color + '44';
    waveCtx.lineWidth = 1;
    waveCtx.beginPath();
    for(let x=0; x<W; x++) {
      const t = x/W * Math.PI*2;
      const y = H/2 - h.amp * (H/2 - 10) * Math.sin(t * h.freq);
      x===0 ? waveCtx.moveTo(x,y) : waveCtx.lineTo(x,y);
    }
    waveCtx.stroke();
  });

  // Sum wave
  waveCtx.strokeStyle = '#ffffff';
  waveCtx.lineWidth = 2;
  waveCtx.shadowColor = '#00ffcc';
  waveCtx.shadowBlur = 8;
  waveCtx.beginPath();
  const totalAmp = harmonics.reduce((a,h)=>a+h.amp,0) || 1;
  for(let x=0; x<W; x++) {
    const t = x/W * Math.PI*2;
    let sum = harmonics.reduce((s,h) => s + h.amp*Math.sin(t*h.freq), 0);
    const y = H/2 - (sum/totalAmp) * (H/2 - 10);
    x===0 ? waveCtx.moveTo(x,y) : waveCtx.lineTo(x,y);
  }
  waveCtx.stroke();
  waveCtx.shadowBlur = 0;
}

function drawSpectrum() {
  const canvas = specCtx.canvas;
  const W = canvas.width, H = canvas.height;
  specCtx.fillStyle = '#12121a';
  specCtx.fillRect(0,0,W,H);

  const maxFreq = 12;
  const barW = W / maxFreq - 2;
  const totalAmp = harmonics.reduce((a,h)=>a+h.amp,0) || 1;

  for(let f=1; f<=maxFreq; f++) {
    const h = harmonics.find(h=>h.freq===f);
    const amp = h ? h.amp : 0;
    const barH = (amp/totalAmp) * (H-30);
    const x = (f-1) * (W/maxFreq) + 4;
    const grad = specCtx.createLinearGradient(0,H,0,H-barH);
    grad.addColorStop(0, '#00ffcc');
    grad.addColorStop(1, '#ff3aff');
    specCtx.fillStyle = h ? grad : 'rgba(255,255,255,0.03)';
    specCtx.fillRect(x, H-barH-20, barW, barH);
    specCtx.fillStyle = '#6060a0';
    specCtx.font = '10px Space Mono';
    specCtx.textAlign = 'center';
    specCtx.fillText(f+'Hz', x+barW/2, H-4);
    if(h) {
      specCtx.fillStyle = h.color;
      specCtx.fillRect(x, H-barH-20, barW, 2);
    }
  }
}

function renderHarmonics() {
  const div = document.getElementById('harmonics');
  div.innerHTML = '';
  harmonics.forEach((h,i) => {
    div.innerHTML += `
    <div class="harmonic-row">
      <div class="harmonic-label" style="color:${h.color}">‚ñ∂ ${h.freq} Hz</div>
      <div class="control-group" style="flex:1">
        <label>Amplitude</label>
        <input type="range" min="0" max="2" step="0.05" value="${h.amp}" oninput="harmonics[${i}].amp=+this.value;updateAll()">
      </div>
      <div class="control-group" style="flex:1">
        <label>Frequenz</label>
        <input type="range" min="1" max="12" step="1" value="${h.freq}" oninput="harmonics[${i}].freq=+this.value;renderHarmonics();updateAll()">
      </div>
      <button class="btn btn-secondary" style="padding:6px 12px; font-size:11px;" onclick="harmonics.splice(${i},1);renderHarmonics();updateAll()">‚úï</button>
    </div>`;
  });
}

function updateAll() { drawWave(); drawSpectrum(); }

function addHarmonic() {
  const usedFreqs = harmonics.map(h=>h.freq);
  let f = 1;
  while(usedFreqs.includes(f)) f++;
  harmonics.push({freq:f, amp:0.5, color:COLORS[harmonics.length%COLORS.length]});
  renderHarmonics();
  updateAll();
}

function clearHarmonics() { harmonics=[]; renderHarmonics(); updateAll(); }

function presetSquare() {
  harmonics = [];
  for(let k=0; k<6; k++) {
    const n = 2*k+1;
    if(n<=12) harmonics.push({freq:n, amp:1/n, color:COLORS[k%COLORS.length]});
  }
  renderHarmonics(); updateAll();
}

function presetSawtooth() {
  harmonics = [];
  for(let n=1; n<=8; n++) {
    harmonics.push({freq:n, amp:1/n, color:COLORS[(n-1)%COLORS.length]});
  }
  renderHarmonics(); updateAll();
}

renderHarmonics(); updateAll();

// =====================================================
// TAB 2: EPIZYKEL
// =====================================================
let epiCycles = [{freq:1, radius:80, color:'#00ffcc', phase:0}];
let epiTime = 0;
let epiTrail = [];
let epiAnimId;

const epiCtx = document.getElementById('epicycleCanvas').getContext('2d');

const EPI_COLORS = ['#00ffcc','#ff3aff','#ffcc00','#3a9fff','#ff6b3a'];

function renderEpiHarmonics() {
  const div = document.getElementById('epi-harmonics');
  div.innerHTML = '';
  epiCycles.forEach((c,i) => {
    div.innerHTML += `
    <div class="harmonic-row">
      <div class="harmonic-label" style="color:${c.color}; font-size:11px;">Kreis ${i+1}</div>
      <div class="control-group" style="flex:1">
        <label>Radius</label>
        <input type="range" min="5" max="120" step="5" value="${c.radius}" oninput="epiCycles[${i}].radius=+this.value">
      </div>
      <div class="control-group" style="flex:1">
        <label>Geschw.</label>
        <input type="range" min="1" max="8" step="1" value="${c.freq}" oninput="epiCycles[${i}].freq=+this.value;epiTrail=[]">
      </div>
      <button class="btn btn-secondary" style="padding:6px 12px; font-size:11px;" onclick="epiCycles.splice(${i},1);renderEpiHarmonics();epiTrail=[]">‚úï</button>
    </div>`;
  });
}

function drawEpicycles() {
  const W = 400, H = 400;
  epiCtx.fillStyle = '#12121a';
  epiCtx.fillRect(0,0,W,H);

  let x = W/2, y = H/2;
  const sorted = [...epiCycles].sort((a,b)=>b.radius-a.radius);

  sorted.forEach(c => {
    const nx = x + c.radius * Math.cos(epiTime * c.freq + c.phase);
    const ny = y + c.radius * Math.sin(epiTime * c.freq + c.phase);

    epiCtx.strokeStyle = c.color + '33';
    epiCtx.lineWidth = 1;
    epiCtx.beginPath();
    epiCtx.arc(x,y,c.radius,0,Math.PI*2);
    epiCtx.stroke();

    epiCtx.strokeStyle = c.color;
    epiCtx.lineWidth = 2;
    epiCtx.beginPath();
    epiCtx.moveTo(x,y);
    epiCtx.lineTo(nx,ny);
    epiCtx.stroke();

    epiCtx.fillStyle = c.color;
    epiCtx.beginPath();
    epiCtx.arc(nx,ny,4,0,Math.PI*2);
    epiCtx.fill();

    x = nx; y = ny;
  });

  epiTrail.push({x,y});
  if(epiTrail.length > 1200) epiTrail.shift();

  if(epiTrail.length > 1) {
    epiCtx.strokeStyle = '#ffffff';
    epiCtx.lineWidth = 1.5;
    epiCtx.shadowColor = '#00ffcc';
    epiCtx.shadowBlur = 4;
    epiCtx.beginPath();
    epiCtx.moveTo(epiTrail[0].x, epiTrail[0].y);
    for(let i=1; i<epiTrail.length; i++) {
      const alpha = i/epiTrail.length;
      epiCtx.strokeStyle = `rgba(255,255,255,${alpha*0.8})`;
      epiCtx.lineTo(epiTrail[i].x, epiTrail[i].y);
    }
    epiCtx.stroke();
    epiCtx.shadowBlur = 0;
  }

  epiTime += 0.025;
  epiAnimId = requestAnimationFrame(drawEpicycles);
}

function addEpiCycle() {
  epiCycles.push({freq: epiCycles.length+1, radius:40, color:EPI_COLORS[epiCycles.length%EPI_COLORS.length], phase:Math.random()*Math.PI*2});
  epiTrail = [];
  renderEpiHarmonics();
}

function clearEpiCycles() {
  epiCycles = [{freq:1, radius:80, color:'#00ffcc', phase:0}];
  epiTrail = [];
  renderEpiHarmonics();
}

renderEpiHarmonics();
drawEpicycles();

// =====================================================
// TAB 3: ZEICHNEN ‚Üí FFT
// =====================================================
const drawCtx = document.getElementById('drawCanvas').getContext('2d');
const drawSpecCtx = document.getElementById('drawSpecCanvas').getContext('2d');
let drawPoints = [];
let isDrawing = false;

function clearDrawing() {
  drawPoints = [];
  const W=500, H=200;
  drawCtx.fillStyle='#12121a'; drawCtx.fillRect(0,0,W,H);
  drawCtx.strokeStyle='rgba(255,255,255,0.1)'; drawCtx.lineWidth=1;
  drawCtx.beginPath(); drawCtx.moveTo(0,H/2); drawCtx.lineTo(W,H/2); drawCtx.stroke();
  drawCtx.strokeStyle='rgba(255,255,255,0.05)';
  for(let x=0;x<W;x+=50){drawCtx.beginPath();drawCtx.moveTo(x,0);drawCtx.lineTo(x,H);drawCtx.stroke();}
  drawSpecCtx.fillStyle='#12121a'; drawSpecCtx.fillRect(0,0,500,200);
  document.getElementById('drawResult').innerHTML='üëÜ Zeichne eine Linie, dann klicke "FFT analysieren".';
}

clearDrawing();

function getCanvasPos(canvas, e) {
  const r = canvas.getBoundingClientRect();
  const scaleX = canvas.width / r.width;
  const scaleY = canvas.height / r.height;
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  return {x:(clientX-r.left)*scaleX, y:(clientY-r.top)*scaleY};
}

const dc = document.getElementById('drawCanvas');
dc.addEventListener('mousedown', e=>{isDrawing=true; drawPoints=[]; const p=getCanvasPos(dc,e); drawCtx.beginPath(); drawCtx.moveTo(p.x,p.y);});
dc.addEventListener('mousemove', e=>{
  if(!isDrawing) return;
  const p=getCanvasPos(dc,e);
  drawPoints.push(p);
  drawCtx.lineTo(p.x,p.y);
  drawCtx.strokeStyle='#00ffcc'; drawCtx.lineWidth=2; drawCtx.stroke();
});
dc.addEventListener('mouseup', ()=>{isDrawing=false;});
dc.addEventListener('touchstart', e=>{e.preventDefault(); isDrawing=true; drawPoints=[]; const p=getCanvasPos(dc,e); drawCtx.beginPath(); drawCtx.moveTo(p.x,p.y);},{passive:false});
dc.addEventListener('touchmove', e=>{
  e.preventDefault();
  if(!isDrawing) return;
  const p=getCanvasPos(dc,e);
  drawPoints.push(p);
  drawCtx.lineTo(p.x,p.y);
  drawCtx.strokeStyle='#00ffcc'; drawCtx.lineWidth=2; drawCtx.stroke();
},{passive:false});
dc.addEventListener('touchend', ()=>{isDrawing=false;});

// Simple DFT
function dft(signal) {
  const N = signal.length;
  const result = [];
  for(let k=0; k<N; k++) {
    let re=0, im=0;
    for(let n=0; n<N; n++) {
      const angle = (2*Math.PI*k*n)/N;
      re += signal[n]*Math.cos(angle);
      im -= signal[n]*Math.sin(angle);
    }
    result.push({freq:k, mag:Math.sqrt(re*re+im*im)/N, re:re/N, im:im/N});
  }
  return result;
}

function analyzeDrawing() {
  if(drawPoints.length < 10) {
    document.getElementById('drawResult').innerHTML='‚ùå Bitte erst eine Kurve zeichnen!';
    return;
  }
  // Sample signal from y-values along x axis
  const W=500, H=200, N=128;
  const signal = new Array(N).fill(H/2);
  drawPoints.forEach(p => {
    const idx = Math.round((p.x/W)*N);
    if(idx>=0 && idx<N) signal[idx] = p.y;
  });
  // Fill gaps
  for(let i=1;i<N;i++) {
    if(signal[i]===H/2 && signal[i-1]!==H/2) signal[i]=signal[i-1];
  }
  const centered = signal.map(y => (H/2 - y));
  
  // Run DFT (only on first 64 for speed)
  const dftResult = dft(centered.slice(0,64));
  
  const W2=500, H2=200;
  drawSpecCtx.fillStyle='#12121a';
  drawSpecCtx.fillRect(0,0,W2,H2);

  const maxMag = Math.max(...dftResult.slice(1,30).map(d=>d.mag)) || 1;
  const barW = W2/30;
  for(let k=1;k<30;k++) {
    const d = dftResult[k];
    const barH = (d.mag/maxMag)*(H2-30);
    const x = (k-1)*barW;
    const grad = drawSpecCtx.createLinearGradient(0,H2,0,H2-barH);
    grad.addColorStop(0,'#ffcc00');
    grad.addColorStop(1,'#ff3aff');
    drawSpecCtx.fillStyle = grad;
    drawSpecCtx.fillRect(x+2, H2-barH-20, barW-4, barH);
    drawSpecCtx.fillStyle='#6060a0';
    drawSpecCtx.font='9px Space Mono';
    drawSpecCtx.textAlign='center';
    drawSpecCtx.fillText(k, x+barW/2, H2-4);
  }
  
  const dominantFreq = dftResult.slice(1,30).reduce((a,b)=>a.mag>b.mag?a:b);
  document.getElementById('drawResult').innerHTML=`
    ‚úÖ <b>FFT-Analyse abgeschlossen!</b><br>
    Dominante Frequenz: <span style="color:#ffcc00">f = ${dominantFreq.freq}</span><br>
    ${dftResult.slice(1,8).filter(d=>d.mag>maxMag*0.1).length} signifikante Frequenzanteile gefunden.<br>
    <span style="color:#6060a0">Eine glatte Sinuswelle hat nur 1 Peak ‚Äî eine eckige Welle hat viele!</span>
  `;
}

// =====================================================
// TAB 4: MIKROFON-SPEKTRUM
// =====================================================
let audioCtx, analyser, micStream, micAnimId;
let micActive = false;

// Init bars
const freqBarsDiv = document.getElementById('freqBars');
const NUM_BARS = 64;
for(let i=0;i<NUM_BARS;i++) {
  const bar = document.createElement('div');
  bar.className = 'freq-bar';
  bar.style.height = '2px';
  freqBarsDiv.appendChild(bar);
}

const specgCtx = document.getElementById('spectrogramCanvas').getContext('2d');
const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
function freqToNote(freq) {
  if(freq < 20) return '‚Äî';
  const n = 12 * Math.log2(freq/440) + 69;
  const note = NOTES[Math.round(n)%12];
  const octave = Math.floor(Math.round(n)/12)-1;
  return note + octave;
}

function drawSpectrogram(dataArray, sampleRate) {
  const W=800, H=120;
  const imgData = specgCtx.getImageData(0,0,W,H);
  specgCtx.putImageData(imgData,0,0);
  const scrolled = specgCtx.getImageData(1,0,W-1,H);
  specgCtx.fillStyle='#12121a';
  specgCtx.fillRect(0,0,W,H);
  specgCtx.putImageData(scrolled,0,0);
  
  for(let y=0;y<H;y++) {
    const freqIdx = Math.floor((y/H)*dataArray.length*0.5);
    const val = dataArray[freqIdx]/255;
    const r = Math.floor(val*255);
    const g = Math.floor(val*val*100);
    const b = Math.floor((1-val)*100);
    specgCtx.fillStyle=`rgb(${r},${g},${b})`;
    specgCtx.fillRect(W-1, H-1-y, 1, 1);
  }
}

async function toggleMic() {
  if(micActive) {
    micActive = false;
    cancelAnimationFrame(micAnimId);
    if(micStream) micStream.getTracks().forEach(t=>t.stop());
    document.getElementById('micBtn').textContent = 'üéôÔ∏è Mikrofon aktivieren';
    document.getElementById('micBtn').className = 'btn btn-primary';
    document.getElementById('spectrumNote').textContent = '‚Äî';
    return;
  }
  try {
    micStream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioCtx = new AudioContext();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.8;
    const source = audioCtx.createMediaStreamSource(micStream);
    source.connect(analyser);
    micActive = true;
    document.getElementById('micBtn').textContent = '‚èπ Mikrofon stoppen';
    document.getElementById('micBtn').className = 'btn btn-secondary';
    
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    const bars = freqBarsDiv.querySelectorAll('.freq-bar');
    
    function update() {
      if(!micActive) return;
      analyser.getByteFrequencyData(dataArray);
      const gain = +document.getElementById('gainSlider').value;
      const step = Math.floor(dataArray.length / NUM_BARS);
      let maxVal=0, maxIdx=0;
      for(let i=0;i<NUM_BARS;i++) {
        let avg=0;
        for(let j=0;j<step;j++) avg += dataArray[i*step+j];
        avg = avg/step;
        const h = Math.min(100, (avg/255)*100*gain);
        bars[i].style.height = h+'%';
        if(avg>maxVal){maxVal=avg;maxIdx=i;}
      }
      const dominantFreq = (maxIdx*step/dataArray.length) * (audioCtx.sampleRate/2);
      document.getElementById('spectrumNote').textContent = maxVal>30 ? freqToNote(dominantFreq)+' ('+Math.round(dominantFreq)+'Hz)' : '‚Äî';
      drawSpectrogram(dataArray, audioCtx.sampleRate);
      micAnimId = requestAnimationFrame(update);
    }
    update();
  } catch(e) {
    alert('Mikrofon-Zugriff verweigert oder nicht verf√ºgbar.\n'+e.message);
  }
}

// =====================================================
// TAB 5: BILD-FFT
// =====================================================
const imgCtx = document.getElementById('imgCanvas').getContext('2d');
const fftCtx = document.getElementById('fftCanvas').getContext('2d');
const filtCtx = document.getElementById('filteredCanvas').getContext('2d');
let currentImgData = null;

function generatePattern(type) {
  const N=256;
  const imgData = imgCtx.createImageData(N,N);
  
  for(let y=0;y<N;y++) for(let x=0;x<N;x++) {
    let v=0;
    if(type==='checker') v = ((Math.floor(x/16)+Math.floor(y/16))%2)*255;
    else if(type==='stripes') v = Math.abs(Math.sin(x*0.2))*255;
    else if(type==='circle') v = (Math.sqrt((x-N/2)**2+(y-N/2)**2) < 60) ? 255 : 0;
    else if(type==='noise') v = Math.random()*255;
    else if(type==='gradient') v = x/N*255;
    const i=(y*N+x)*4;
    imgData.data[i]=v; imgData.data[i+1]=v; imgData.data[i+2]=v; imgData.data[i+3]=255;
  }
  imgCtx.putImageData(imgData, 0, 0);
  currentImgData = imgData;
  
  // Compute 2D FFT (simplified: row-by-row DFT then column-by-column)
  compute2DFFT(imgData, N);
  applyFilter();
  
  const desc = {
    checker: '‚ôü <b>Schachbrett</b>: Die FFT zeigt ein regelm√§√üiges Gittermuster ‚Äî die Periodizit√§t ist klar sichtbar!',
    stripes: '„Ä∞Ô∏è <b>Streifen</b>: Nur horizontale Frequenzen ‚Üí die FFT-Punkte liegen auf einer Linie.',
    circle: '‚≠ï <b>Kreis</b>: Eine konzentrische Ringe-Struktur im Spektrum (Airy-Muster).',
    noise: 'üé≤ <b>Rauschen</b>: Alle Frequenzen gleichm√§√üig stark ‚Üí wei√ües Spektrum.',
    gradient: 'üåÖ <b>Verlauf</b>: Nur tiefe Frequenzen dominieren ‚Üí Energie nahe dem Zentrum.'
  };
  document.getElementById('imgInfo').innerHTML = 'üí° ' + desc[type];
}

function compute2DFFT(imgData, N) {
  // Extract grayscale
  const grid = [];
  for(let y=0;y<N;y++) {
    grid.push([]);
    for(let x=0;x<N;x++) {
      grid[y].push(imgData.data[(y*N+x)*4]/255);
    }
  }
  
  // Compute magnitude spectrum (naive DFT but only for visualization, use reduced resolution)
  const R = 64; // reduced for speed
  const mag = new Float32Array(R*R);
  const step = N/R;
  
  for(let ky=0;ky<R;ky++) for(let kx=0;kx<R;kx++) {
    let re=0,im=0;
    for(let y=0;y<N;y+=4) for(let x=0;x<N;x+=4) {
      const angle = 2*Math.PI*((kx*x/N)+(ky*y/N));
      re += grid[y][x]*Math.cos(angle);
      im -= grid[y][x]*Math.sin(angle);
    }
    mag[ky*R+kx] = Math.sqrt(re*re+im*im);
  }
  
  // Log scale and draw, centered
  const maxM = Math.max(...mag);
  const fftImgData = fftCtx.createImageData(256,256);
  for(let ky=0;ky<R;ky++) for(let kx=0;kx<R;kx++) {
    const v = Math.log1p(mag[ky*R+kx]/maxM*100)/Math.log1p(100)*255;
    // Center shift
    const dx = (kx+R/2)%R, dy = (ky+R/2)%R;
    const scale = 256/R;
    for(let sy=0;sy<scale;sy++) for(let sx=0;sx<scale;sx++) {
      const px = (Math.floor(dx*scale)+sx), py = (Math.floor(dy*scale)+sy);
      if(px>=256||py>=256) continue;
      const i=(py*256+px)*4;
      fftImgData.data[i]=v*0.2;
      fftImgData.data[i+1]=v;
      fftImgData.data[i+2]=v*0.6;
      fftImgData.data[i+3]=255;
    }
  }
  fftCtx.putImageData(fftImgData,0,0);
}

function applyFilter() {
  if(!currentImgData) return;
  const N=256;
  const radius = +document.getElementById('filterRadius').value;
  // Simple low-pass: blur by averaging
  const sigma = (128-radius)/10 + 1;
  const src = currentImgData.data;
  const filtImgData = filtCtx.createImageData(N,N);
  // Box blur approximation
  const kSize = Math.max(1, Math.round((128-radius)/10));
  for(let y=0;y<N;y++) for(let x=0;x<N;x++) {
    let sum=0, cnt=0;
    for(let dy=-kSize;dy<=kSize;dy++) for(let dx=-kSize;dx<=kSize;dx++) {
      const nx=x+dx, ny=y+dy;
      if(nx>=0&&nx<N&&ny>=0&&ny<N){sum+=src[(ny*N+nx)*4];cnt++;}
    }
    const v=sum/cnt;
    const i=(y*N+x)*4;
    filtImgData.data[i]=v;filtImgData.data[i+1]=v;filtImgData.data[i+2]=v;filtImgData.data[i+3]=255;
  }
  filtCtx.putImageData(filtImgData,0,0);
}

generatePattern('checker');
</script>
</body>
</html>
